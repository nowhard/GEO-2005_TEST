//----------------------------------------------------------------------------
//      Описание микросхемы RTC и NVRAM FM30C256, а также описание
//       функций работы с ней.
//----------------------------------------------------------------------------
#ifndef FM30C256_H
#define	FM30C256_H

#include "pt/pt.h"
#include "i2c.h"

// Fдреса шины I2C, относящиеся к RTC и NVRAM:
#define SLAVEID_NVRAM 0xAE//0xA0
#define SLAVEID_RTC   0xDE//0xD0
// Ножки A0..A1, задающие адрес I2C, посажены на 1, поэтому адрес микросхемы
//  
#define DEV_ADR 0
#define NVRAM_ADR (DEV_ADR | (SLAVEID_NVRAM >> 1))
#define   RTC_ADR (DEV_ADR | (SLAVEID_RTC   >> 1))

#define NVRAM_SIZE 32768    /* размер энергонезависимой памяти в байтах */

// У микросхемы всего 9 регистров, отвечающие за RTC и TAMPER. Эти регистры 
//  защищаются батарейкой 3 вольт (3.25 вольт, когда полностью заряжена).
// Адреса регистров следующие:
//---------------------
// флаги и управление
//---------------------
#define RTC_FLAGS_CONTROL_ADR   0
// Маски для битов FLAGS_CONTROL_ADR:
//      D7  Tamper, устанавливается по возрастанию TIN. Сбросить можно только 
//          программно.
#define RTC_Tamper  (1<<7)
//      D6  CF, Century Overflow Flag (флаг переполнения столетия), read-only. 
//          Устанавливается, года регистр года переходит из 99 в 00.
//          Очищается при чтении регистра FLAGS_CONTROL_ADR.
#define RTC_CF      (1<<6)
//      D5  reserved, должен быть всегда 0
//      D4  reserved, должен быть всегда 0
//      D3  TST, должен быть всегда равен 0.
//      D2  CAL, если ==1, то включает режим калибровки. При этом на ноге CAL 
//          (выход микросхемы) появляется частота 512 Гц. Если CAL==0, то на 
//          ножке CAL появляется 0.
#define RTC_CAL     (1<<2)
//      D1  W, Write Time. Если записать туда 1, то ход часов приостанавливается.
//          При этом пользователь может обновить регистры часов (для установки
//          времени, например). Запись 0 переносит содержимое регистров времени
//          в счетчики времени.
#define RTC_W       (1<<1)
//      D0  R, Read Time. Переход из 0 в 1 захватывает содержимое счетчиков 
//          времени в специальные удерживающие регистры, чтобы можно было считать
//          текущее время. Перед тем, как получить новое время, нужно R снова
//          сбросить в 0.
#define RTC_R       (1<<0)

//--------------------------
// Калибровка и управление
//--------------------------
#define RTC_CAL_CONTROL_ADR     1
// Маски для битов CAL_CONTROL_ADR:
//      D7  ~OSCEN, запись туда 1 останавливает тактовый генератор, что уменьшает
//          энергопотребление. После включения питания без батарейки этот бит
//          автоматически устанавливается в 1.
#define _OSCEN  (1<<7)
//      D6  TSEN, Time Stamp Enable. Если установить в 1, то событие Tamper 
//          (возрастание напряжения на ноге TIN) будет записывать время этого 
//          события.
#define TSEN    (1<<6)
//      D5  CALS, Calibration sign. Определяет, добавляется ли или отнимается 
//          значение калибровки
#define CALS    (1<<5)
//      D4..D0  CAL.4-0 значение калибровки. Это значение можно записать только
//          тогда, когда CAL==1.

//---------------------------------------------------------------------------
// Секунды, минуты, часы, дни недели, дни месяца, месяцы, годы.
// Читают     эти регистры, предварительно переведя бит R из 0 в 1.
// Записывают эти регистры, предварительно переведя бит W из 0 в 1.
// По окончании чтения/записи биты R/W соответственно надо вернуть в 0.
//---------------------------------------------------------------------------
#define RTC_TIME_SECONDS        2
#define RTC_TIME_MINUTES        3
#define RTC_TIME_HOURS          4
#define RTC_TIME_DAY_WEEK       5
#define RTC_TIME_DAY_MONTH      6
#define RTC_TIME_MONTHS         7
#define RTC_TIME_YEARS          8

struct tTime
{
    unsigned char Second;			// Секунда
	unsigned char Minute;			// Минута
	unsigned char Hour;				// Час
	unsigned char WeekDay;  		// День недели
	unsigned char Day;		    	// День			
	unsigned char Month;			// Месяц
	unsigned char Year;				// Год
};
    
//---------------------------------------------------------------------------
//  Протокол обмена прост. Первый байт, который ожидает микросхема после 
//   STARTCOND - slave address. Биты 7..4 у него задают RTC или NVRAM
//   (константы SLAVEID_RTC и SLAVEID_NVRAM), биты 3..1 должны быть 0 
//   (так как ножки A2..A0 заземлены), а бит 0 (бит R/~W) определяет запись 
//   (==0) или чтение (==1).
//
//  [адресация NVRAM]
//  Следующие 2 байта передают адрес.  Первым идет старший байт (MSB), 
//   у которого бит 7 должен быть сброшен (у нас всего 32768 ячеек памяти),
//   затем идет младший байт (LSB). Каждый доступ к памяти автоматически 
//   увеличивает указатель адреса. По достижении величины 0x7FFF автоматически
//   происходит переход к адресу 0x0000.
//
//  [адресация RTC]
//  Следующий 1 байт передает адрес регистра. Старший ниббл адреса 
//   не принимается во внимание, однако величины адреса 9..F являются 
//   недопустимыми и не могут использоваться, иначе могут быть
//   непредсказуемые ошибки.
//

PT_THREAD(FM_Read_Time(struct pt *pt,struct tTime *Time));//чтение времени с fm30c256
PT_THREAD(FM_Write_Time(struct pt *pt,struct tTime *Time));//запись нового значения времени на fm30c256
#endif